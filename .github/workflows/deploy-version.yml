name: Deploy API Version

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1, v2, v4)'
        required: true
        type: string
      deploy_all:
        description: 'Deploy all services'
        required: false
        type: boolean
        default: true
      deploy_package:
        description: 'Deploy package service'
        required: false
        type: boolean
        default: false
      deploy_lender:
        description: 'Deploy lender service'
        required: false
        type: boolean
        default: false
      deploy_product:
        description: 'Deploy product service'
        required: false
        type: boolean
        default: false
      deploy_document:
        description: 'Deploy document service'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
        default: 'dev'

env:
  AWS_REGION: us-east-1
  GITHUB_ORG: rgcleanslage

concurrency:
  group: deploy-${{ github.event.inputs.version }}-${{ github.event.inputs.environment }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: write

jobs:
  validate-version:
    name: Validate Version from GitHub Releases
    runs-on: ubuntu-latest
    outputs:
      services-list: ${{ steps.parse.outputs.services }}
      version-status: ${{ steps.validate.outputs.status }}
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4

      - name: Validate version exists in releases
        id: validate
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          VERSION="${{ github.event.inputs.version }}"

          echo "ğŸ” Checking GitHub Release for api-${VERSION}..."

          # Fetch release metadata
          RELEASE_BODY=$(gh release view "api-${VERSION}" --json body --jq '.body' 2>/dev/null)

          if [ -z "$RELEASE_BODY" ]; then
            echo "âŒ Version $VERSION not found as a GitHub Release (api-${VERSION})"
            exit 1
          fi

          # Extract JSON metadata from release body
          STATUS=$(echo "$RELEASE_BODY" | sed -n '/```json/,/```/p' | sed '1d;$d' | jq -r '.status')
          echo "status=$STATUS" >> $GITHUB_OUTPUT

          echo "âœ… Version $VERSION is valid (status: $STATUS)"

          if [ "$STATUS" == "sunset" ]; then
            echo "âŒ Cannot deploy sunset version $VERSION"
            exit 1
          fi

      - name: Validate release branch exists
        run: |
          VERSION="${{ github.event.inputs.version }}"

          for SERVICE in package lender product document; do
            if ! git ls-remote --heads "https://github.com/${{ env.GITHUB_ORG }}/iqq-${SERVICE}-service.git" "release/$VERSION" | grep -q "release/$VERSION"; then
              echo "âš ï¸  Warning: release/$VERSION branch not found in iqq-${SERVICE}-service"
            else
              echo "âœ… release/$VERSION branch exists in iqq-${SERVICE}-service"
            fi
          done

      - name: Parse services list
        id: parse
        run: |
          SERVICES=""

          if [ "${{ github.event.inputs.deploy_all }}" == "true" ]; then
            SERVICES="package,lender,product,document"
          else
            [ "${{ github.event.inputs.deploy_package }}" == "true" ] && SERVICES="${SERVICES}package,"
            [ "${{ github.event.inputs.deploy_lender }}" == "true" ] && SERVICES="${SERVICES}lender,"
            [ "${{ github.event.inputs.deploy_product }}" == "true" ] && SERVICES="${SERVICES}product,"
            [ "${{ github.event.inputs.deploy_document }}" == "true" ] && SERVICES="${SERVICES}document,"
            SERVICES="${SERVICES%,}"

            if [ -z "$SERVICES" ]; then
              echo "âŒ No services selected for deployment"
              exit 1
            fi
          fi

          SERVICES_JSON=$(echo "$SERVICES" | jq -Rc 'split(",") | map(select(length > 0))')
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Services to deploy: $SERVICES"

  deploy-services:
    name: Deploy ${{ matrix.service }} Service
    needs: validate-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.validate-version.outputs.services-list) }}
      fail-fast: false
      max-parallel: 2
    steps:
      - name: Trigger service deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const service = '${{ matrix.service }}';
            const version = '${{ github.event.inputs.version }}';
            const environment = '${{ github.event.inputs.environment }}';

            console.log(`ğŸš€ Triggering deployment for iqq-${service}-service`);

            let ref = `release/${version}`;
            try {
              await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: `iqq-${service}-service`,
                branch: ref
              });
              console.log(`âœ… Using release branch: ${ref}`);
            } catch (error) {
              console.log(`âš ï¸  Release branch ${ref} not found, using main`);
              ref = 'main';
            }

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: `iqq-${service}-service`,
              workflow_id: 'deploy.yml',
              ref: ref,
              inputs: {
                version: version,
                environment: environment,
                triggered_by: 'root-repository'
              }
            });

            console.log(`âœ… Deployment triggered for iqq-${service}-service from ${ref}`);

      - name: Wait for deployment to start
        run: sleep 10

      - name: Monitor deployment status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const service = '${{ matrix.service }}';
            const maxAttempts = 60;
            const delayMs = 10000;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: `iqq-${service}-service`,
                workflow_id: 'deploy.yml',
                per_page: 5
              });

              const latestRun = runs.data.workflow_runs[0];
              if (!latestRun) {
                console.log(`â³ Attempt ${attempt}/${maxAttempts}: No runs found yet`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
                continue;
              }

              console.log(`ğŸ“ Attempt ${attempt}/${maxAttempts}: Status = ${latestRun.status}, Conclusion = ${latestRun.conclusion}`);

              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log(`âœ… Deployment completed successfully`);
                  return;
                } else {
                  throw new Error(`Deployment failed for iqq-${service}-service: ${latestRun.conclusion}`);
                }
              }

              await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            throw new Error(`Deployment timeout for iqq-${service}-service`);

  verify-deployments:
    name: Verify Service Deployments
    needs: update-api-gateway
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get OAuth token
        id: auth
        run: |
          USER_POOL_ID=$(aws cognito-idp list-user-pools --max-results 10 \
            --query 'UserPools[?Name==`iqq-dev-user-pool`].Id' --output text)

          DOMAIN=$(aws cognito-idp describe-user-pool --user-pool-id "$USER_POOL_ID" \
            --query 'UserPool.Domain' --output text 2>/dev/null || echo "iqq-dev-ib9i1hvt")

          CLIENT_ID=$(aws secretsmanager get-secret-value \
            --secret-id "iqq-dev-cognito-client-default" \
            --query 'SecretString' --output text | jq -r '.client_id')

          CLIENT_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id "iqq-dev-cognito-client-default" \
            --query 'SecretString' --output text | jq -r '.client_secret')

          API_KEY=$(aws secretsmanager get-secret-value \
            --secret-id "iqq-dev-api-key-default" \
            --query 'SecretString' --output text | jq -r '.api_key')

          TOKEN=$(curl -s -X POST "https://${DOMAIN}.auth.us-east-1.amazoncognito.com/oauth2/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -u "${CLIENT_ID}:${CLIENT_SECRET}" \
            -d "grant_type=client_credentials" | jq -r '.access_token')

          echo "::add-mask::$TOKEN"
          echo "::add-mask::$API_KEY"
          echo "::add-mask::$CLIENT_SECRET"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "api_key=$API_KEY" >> $GITHUB_OUTPUT

      - name: Wait for API Gateway propagation
        run: |
          echo "â³ Waiting 30 seconds for API Gateway deployment to propagate..."
          sleep 30

      - name: Test deployed services
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
          API_KEY: ${{ steps.auth.outputs.api_key }}
          VERSION: ${{ github.event.inputs.version }}
        run: |
          echo "ğŸ§ª Testing deployed services on version $VERSION"

          MAX_RETRIES=3
          RETRY_DELAY=10

          FAILED=0
          for SERVICE in package lender product document; do
            echo ""
            echo "Testing $SERVICE service..."

            case $SERVICE in
              package)  PARAMS="?productCode=MBP" ;;
              lender)   PARAMS="?lenderId=LENDER-001" ;;
              product)  PARAMS="?productId=PROD-001" ;;
              document) PARAMS="" ;;
            esac

            # Retry logic for each service
            SUCCESS=0
            for ATTEMPT in $(seq 1 $MAX_RETRIES); do
              if [ $ATTEMPT -gt 1 ]; then
                echo "  â³ Retry attempt $ATTEMPT/$MAX_RETRIES (waiting ${RETRY_DELAY}s)..."
                sleep $RETRY_DELAY
              fi

              RESPONSE=$(curl -s -w "\n%{http_code}" \
                -H "Authorization: Bearer $TOKEN" \
                -H "x-api-key: $API_KEY" \
                "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/$VERSION/$SERVICE$PARAMS")

              HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
              BODY=$(echo "$RESPONSE" | sed '$d')

              if [ "$HTTP_CODE" -eq 200 ]; then
                API_VERSION=$(echo "$BODY" | jq -r '.metadata.apiVersion // empty')
                echo "  âœ… HTTP 200 - Service responding"
                [ ! -z "$API_VERSION" ] && echo "  âœ… Version header: $API_VERSION"
                SUCCESS=1
                break
              elif [ $ATTEMPT -eq $MAX_RETRIES ]; then
                echo "  âŒ HTTP $HTTP_CODE - Service failed after $MAX_RETRIES attempts"
                echo "$BODY" | jq . 2>/dev/null || echo "$BODY"
              fi
            done

            if [ $SUCCESS -eq 0 ]; then
              FAILED=1
            fi
          done

          if [ $FAILED -eq 1 ]; then
            echo ""
            echo "âŒ Some services failed verification after retries"
            exit 1
          fi

          echo ""
          echo "âœ… All services verified successfully"

  update-api-gateway:
    name: Update API Gateway
    needs: [validate-version, deploy-services]
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get API Gateway ID
        id: get-api
        run: |
          API_ID=$(aws apigateway get-rest-apis \
            --query 'items[?name==`iqq-api-dev`].id' --output text)
          if [ -z "$API_ID" ]; then
            echo "âŒ API Gateway not found"
            exit 1
          fi
          echo "api_id=$API_ID" >> $GITHUB_OUTPUT

      - name: Update Lambda permissions
        run: |
          VERSION="${{ github.event.inputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          
          for SERVICE in package lender product document; do
            FUNCTION_NAME="iqq-${SERVICE}-service-dev"
            STATEMENT_ID="apigateway-${VERSION}-invoke"
            
            # Check if alias exists
            if ! aws lambda get-alias --function-name "$FUNCTION_NAME" --name "$VERSION" 2>/dev/null; then
              echo "âš ï¸  Alias $VERSION does not exist for $FUNCTION_NAME, skipping permission"
              continue
            fi
            
            # Remove old permission if exists
            aws lambda remove-permission \
              --function-name "${FUNCTION_NAME}:${VERSION}" \
              --statement-id "$STATEMENT_ID" 2>/dev/null || true
            
            # Add permission for the alias
            aws lambda add-permission \
              --function-name "${FUNCTION_NAME}:${VERSION}" \
              --statement-id "$STATEMENT_ID" \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${AWS_REGION}:${ACCOUNT_ID}:${API_ID}/${VERSION}/*/*" \
              && echo "âœ… Permission added for ${FUNCTION_NAME}:${VERSION}" \
              || echo "âš ï¸  Permission issue for ${FUNCTION_NAME}:${VERSION}"
          done

      - name: Update usage plans
        run: |
          VERSION="${{ github.event.inputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"
          
          # Get all usage plans
          USAGE_PLANS=$(aws apigateway get-usage-plans --query 'items[].id' --output text)
          
          for PLAN_ID in $USAGE_PLANS; do
            PLAN_NAME=$(aws apigateway get-usage-plan --usage-plan-id "$PLAN_ID" --query 'name' --output text)
            
            # Check if stage already in plan
            STAGES=$(aws apigateway get-usage-plan --usage-plan-id "$PLAN_ID" --query 'apiStages[].stage' --output text)
            
            if echo "$STAGES" | grep -q "$VERSION"; then
              echo "â„¹ï¸  Stage $VERSION already in usage plan $PLAN_NAME"
            else
              aws apigateway update-usage-plan \
                --usage-plan-id "$PLAN_ID" \
                --patch-operations op=add,path=/apiStages,value="${API_ID}:${VERSION}" \
                && echo "âœ… Added $VERSION to usage plan $PLAN_NAME" \
                || echo "âš ï¸  Failed to add $VERSION to usage plan $PLAN_NAME"
            fi
          done

      - name: Redeploy API Gateway stage
        run: |
          VERSION="${{ github.event.inputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"

          if ! aws apigateway get-stage --rest-api-id "$API_ID" --stage-name "$VERSION" 2>/dev/null; then
            echo "âŒ Stage $VERSION does not exist. Run 'Add New API Version' workflow first."
            exit 1
          fi

          aws apigateway create-deployment \
            --rest-api-id "$API_ID" \
            --stage-name "$VERSION" \
            --description "Redeployment triggered by version deployment workflow"

          echo "âœ… API Gateway redeployment complete for $VERSION"

  update-release-metadata:
    name: Update Release Metadata
    needs: update-api-gateway
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update GitHub Release with deploy timestamp
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          VERSION="${{ github.event.inputs.version }}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Get current release body
          RELEASE_BODY=$(gh release view "api-${VERSION}" --json body --jq '.body')

          # Update the lastDeployed field in the JSON metadata
          UPDATED_BODY=$(echo "$RELEASE_BODY" | sed "s/\"lastDeployed\": *null/\"lastDeployed\": \"${TIMESTAMP}\"/")

          gh release edit "api-${VERSION}" --notes "$UPDATED_BODY"

          echo "âœ… Updated release api-${VERSION} with deploy timestamp: $TIMESTAMP"

  notify-completion:
    name: Notify Completion
    needs: [validate-version, update-release-metadata]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Deployment summary
        run: |
          VERSION="${{ github.event.inputs.version }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ API Version Deployment Complete"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Version: $VERSION"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Status: ${{ job.status }}"
          echo ""
          echo "âœ… All services deployed and verified"
          echo "âœ… API Gateway updated"
          echo "âœ… GitHub Release metadata updated"
          echo ""
          echo "ğŸ”— API Endpoints:"
          echo "   https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/$VERSION/"
          echo ""
