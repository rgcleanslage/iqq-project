name: Deploy API Version

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (v1, v2)'
        required: true
        type: choice
        options:
          - v1
          - v4
          - v2
      deploy_all:
        description: 'Deploy all services'
        required: false
        type: boolean
        default: true
      deploy_package:
        description: 'Deploy package service'
        required: false
        type: boolean
        default: false
      deploy_lender:
        description: 'Deploy lender service'
        required: false
        type: boolean
        default: false
      deploy_product:
        description: 'Deploy product service'
        required: false
        type: boolean
        default: false
      deploy_document:
        description: 'Deploy document service'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - v4
        default: 'dev'

env:
  AWS_REGION: us-east-1
  GITHUB_ORG: rgcleanslage

concurrency:
  group: deploy-${{ github.event.inputs.version }}-${{ github.event.inputs.environment }}
  cancel-in-progress: false

jobs:
  validate-version:
    name: Validate Version Configuration
    runs-on: ubuntu-latest
    outputs:
      services-list: ${{ steps.parse.outputs.services }}
      version-status: ${{ steps.validate.outputs.status }}
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4
      
      - name: Validate release branch exists
        run: |
          VERSION="${{ github.event.inputs.version }}"
          
          echo "ğŸ” Validating release branch for $VERSION..."
          
          # Check each service repository for release branch
          for SERVICE in package lender product document; do
            echo "Checking iqq-${SERVICE}-service..."
            
            if ! git ls-remote --heads "https://github.com/${{ env.GITHUB_ORG }}/iqq-${SERVICE}-service.git" "release/$VERSION" | grep -q "release/$VERSION"; then
              echo "âš ï¸  Warning: release/$VERSION branch not found in iqq-${SERVICE}-service"
              echo "   Deployment will use main branch"
            else
              echo "âœ… release/$VERSION branch exists in iqq-${SERVICE}-service"
            fi
          done
      
      - name: Parse services list
        id: parse
        run: |
          SERVICES=""
          
          # Check if deploy all is selected
          if [ "${{ github.event.inputs.deploy_all }}" == "true" ]; then
            SERVICES="package,lender,product,document"
          else
            # Build list from individual checkboxes
            [ "${{ github.event.inputs.deploy_package }}" == "true" ] && SERVICES="${SERVICES}package,"
            [ "${{ github.event.inputs.deploy_lender }}" == "true" ] && SERVICES="${SERVICES}lender,"
            [ "${{ github.event.inputs.deploy_product }}" == "true" ] && SERVICES="${SERVICES}product,"
            [ "${{ github.event.inputs.deploy_document }}" == "true" ] && SERVICES="${SERVICES}document,"
            
            # Remove trailing comma
            SERVICES="${SERVICES%,}"
            
            # If no services selected, fail
            if [ -z "$SERVICES" ]; then
              echo "âŒ No services selected for deployment"
              exit 1
            fi
          fi
          
          # Convert comma-separated list to JSON array (compact, no newlines)
          SERVICES_JSON=$(echo "$SERVICES" | jq -Rc 'split(",") | map(select(length > 0))')
          
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Services to deploy: $SERVICES"
          echo "ğŸ“¦ Services JSON: $SERVICES_JSON"
      
      - name: Validate version configuration
        id: validate
        run: |
          VERSION="${{ github.event.inputs.version }}"
          
          # Check if version exists in configuration
          if ! jq -e ".versions[\"$VERSION\"]" config/version-policy.json > /dev/null; then
            echo "âŒ Version $VERSION not found in configuration"
            exit 1
          fi
          
          # Get version status
          STATUS=$(jq -r ".versions[\"$VERSION\"].status" config/version-policy.json)
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          
          echo "âœ… Version $VERSION is valid (status: $STATUS)"
          
          # Check if version is sunset
          if [ "$STATUS" == "sunset" ]; then
            echo "âŒ Cannot deploy sunset version $VERSION"
            exit 1
          fi

  deploy-services:
    name: Deploy ${{ matrix.service }} Service
    needs: validate-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.validate-version.outputs.services-list) }}
      fail-fast: false
      max-parallel: 2
    steps:
      - name: Trigger service deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const service = '${{ matrix.service }}';
            const version = '${{ github.event.inputs.version }}';
            const environment = '${{ github.event.inputs.environment }}';
            
            console.log(`ğŸš€ Triggering deployment for iqq-${service}-service`);
            console.log(`   Version: ${version}`);
            console.log(`   Environment: ${environment}`);
            console.log(`   Branch: release/${version} (fallback to main if not exists)`);
            
            try {
              // Try to deploy from release branch first, fallback to main
              let ref = `release/${version}`;
              
              // Check if release branch exists
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: `iqq-${service}-service`,
                  branch: ref
                });
                console.log(`âœ… Using release branch: ${ref}`);
              } catch (error) {
                console.log(`âš ï¸  Release branch ${ref} not found, using main`);
                ref = 'main';
              }
              
              const response = await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: `iqq-${service}-service`,
                workflow_id: 'deploy.yml',
                ref: ref,
                inputs: {
                  version: version,
                  environment: environment,
                  triggered_by: 'root-repository'
                }
              });
              
              console.log(`âœ… Deployment triggered for iqq-${service}-service from ${ref}`);
            } catch (error) {
              console.error(`âŒ Failed to trigger deployment: ${error.message}`);
              throw error;
            }
      
      - name: Wait for deployment to start
        run: |
          echo "â³ Waiting for deployment to start..."
          sleep 10
      
      - name: Monitor deployment status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const service = '${{ matrix.service }}';
            const maxAttempts = 60; // 10 minutes max
            const delayMs = 10000; // 10 seconds between checks
            
            console.log(`ğŸ“Š Monitoring deployment for iqq-${service}-service`);
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              // Get recent workflow runs
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: `iqq-${service}-service`,
                workflow_id: 'deploy.yml',
                per_page: 5
              });
              
              // Find the most recent run
              const latestRun = runs.data.workflow_runs[0];
              
              if (!latestRun) {
                console.log(`â³ Attempt ${attempt}/${maxAttempts}: No runs found yet`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
                continue;
              }
              
              console.log(`ğŸ“ Attempt ${attempt}/${maxAttempts}: Status = ${latestRun.status}, Conclusion = ${latestRun.conclusion}`);
              
              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log(`âœ… Deployment completed successfully`);
                  return;
                } else {
                  console.error(`âŒ Deployment failed with conclusion: ${latestRun.conclusion}`);
                  throw new Error(`Deployment failed for iqq-${service}-service`);
                }
              }
              
              await new Promise(resolve => setTimeout(resolve, delayMs));
            }
            
            console.error(`âŒ Deployment timed out after ${maxAttempts} attempts`);
            throw new Error(`Deployment timeout for iqq-${service}-service`);

  verify-deployments:
    name: Verify Service Deployments
    needs: deploy-services
    runs-on: ubuntu-latest
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get OAuth token
        id: auth
        run: |
          # Get Cognito User Pool ID
          USER_POOL_ID=$(aws cognito-idp list-user-pools --max-results 10 \
            --query 'UserPools[?Name==`iqq-dev-user-pool`].Id' \
            --output text)
          
          # Get User Pool Domain
          DOMAIN=$(aws cognito-idp describe-user-pool --user-pool-id "$USER_POOL_ID" \
            --query 'UserPool.Domain' --output text 2>/dev/null || echo "iqq-dev-ib9i1hvt")
          
          # Get client credentials from Secrets Manager
          CLIENT_ID=$(aws secretsmanager get-secret-value \
            --secret-id "iqq-dev-cognito-client-default" \
            --query 'SecretString' --output text | jq -r '.client_id')
          
          CLIENT_SECRET=$(aws secretsmanager get-secret-value \
            --secret-id "iqq-dev-cognito-client-default" \
            --query 'SecretString' --output text | jq -r '.client_secret')
          
          # Get API Key from Secrets Manager
          API_KEY=$(aws secretsmanager get-secret-value \
            --secret-id "iqq-dev-api-key-default" \
            --query 'SecretString' --output text | jq -r '.api_key')
          
          TOKEN=$(curl -s -X POST "https://${DOMAIN}.auth.us-east-1.amazoncognito.com/oauth2/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -u "${CLIENT_ID}:${CLIENT_SECRET}" \
            -d "grant_type=client_credentials" | jq -r '.access_token')
          
          echo "::add-mask::$TOKEN"
          echo "::add-mask::$API_KEY"
          echo "::add-mask::$CLIENT_SECRET"
          echo "token=$TOKEN" >> $GITHUB_OUTPUT
          echo "api_key=$API_KEY" >> $GITHUB_OUTPUT
      
      - name: Test deployed services
        env:
          TOKEN: ${{ steps.auth.outputs.token }}
          API_KEY: ${{ steps.auth.outputs.api_key }}
          VERSION: ${{ github.event.inputs.version }}
        run: |
          SERVICES="${{ needs.validate-version.outputs.services-list }}"
          IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
          
          echo "ğŸ§ª Testing deployed services on version $VERSION"
          
          FAILED=0
          for SERVICE in "${SERVICE_ARRAY[@]}"; do
            echo ""
            echo "Testing $SERVICE service..."
            
            # Determine test parameters based on service
            case $SERVICE in
              package)
                PARAMS="?productCode=MBP"
                ;;
              lender)
                PARAMS="?lenderId=LENDER-001"
                ;;
              product)
                PARAMS="?productId=PROD-001"
                ;;
              document)
                PARAMS=""
                ;;
            esac
            
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: Bearer $TOKEN" \
              -H "x-api-key: $API_KEY" \
              "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/$VERSION/$SERVICE$PARAMS")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" -eq 200 ]; then
              # Verify version header in response
              API_VERSION=$(echo "$BODY" | jq -r '.metadata.apiVersion // empty')
              echo "  âœ… HTTP 200 - Service responding"
              if [ ! -z "$API_VERSION" ]; then
                echo "  âœ… Version header present: $API_VERSION"
              fi
            else
              echo "  âŒ HTTP $HTTP_CODE - Service failed"
              echo "$BODY" | jq . || echo "$BODY"
              FAILED=1
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo ""
            echo "âŒ Some services failed verification"
            exit 1
          fi
          
          echo ""
          echo "âœ… All services verified successfully"

  update-api-gateway:
    name: Update API Gateway
    needs: verify-deployments
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get API Gateway ID
        id: get-api
        run: |
          # Get API Gateway ID from existing deployment
          API_ID=$(aws apigateway get-rest-apis \
            --query 'items[?name==`iqq-api-dev`].id' \
            --output text)
          
          if [ -z "$API_ID" ]; then
            echo "âŒ API Gateway not found"
            exit 1
          fi
          
          echo "api_id=$API_ID" >> $GITHUB_OUTPUT
          echo "âœ… API Gateway ID: $API_ID"
      
      - name: Verify API Gateway stage
        run: |
          VERSION="${{ github.event.inputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"
          
          echo "ğŸ” Checking API Gateway stage: $VERSION"
          
          # Check if stage exists
          if aws apigateway get-stage \
            --rest-api-id "$API_ID" \
            --stage-name "$VERSION" 2>/dev/null; then
            echo "âœ… Stage $VERSION exists"
          else
            echo "âŒ Stage $VERSION does not exist"
            echo "   Run 'Add New API Version' workflow first to create the stage"
            exit 1
          fi
          
          # Trigger redeployment to ensure latest Lambda versions
          echo "ğŸ”„ Triggering API Gateway redeployment..."
          aws apigateway create-deployment \
            --rest-api-id "$API_ID" \
            --stage-name "$VERSION" \
            --description "Redeployment triggered by version deployment workflow"
          
          echo "âœ… API Gateway redeployment complete"

  update-version-policy:
    name: Update Version Policy
    needs: update-api-gateway
    runs-on: ubuntu-latest
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
      
      - name: Update version policy
        run: |
          VERSION="${{ github.event.inputs.version }}"
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          # Update last deployed timestamp
          jq --arg version "$VERSION" \
             --arg timestamp "$TIMESTAMP" \
             '.versions[$version].lastDeployed = $timestamp' \
             config/version-policy.json > config/version-policy.json.tmp
          
          mv config/version-policy.json.tmp config/version-policy.json
          
          echo "âœ… Updated version policy for $VERSION"
          echo "   Timestamp: $TIMESTAMP"
      
      - name: Commit and push changes
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add config/version-policy.json
          git commit -m "chore: update version policy - ${{ github.event.inputs.version }} deployed at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          git push

  notify-completion:
    name: Notify Completion
    needs: update-version-policy
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Deployment summary
        run: |
          VERSION="${{ github.event.inputs.version }}"
          SERVICES="${{ needs.validate-version.outputs.services-list }}"
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ API Version Deployment Complete"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Version: $VERSION"
          echo "Services: $SERVICES"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Status: ${{ job.status }}"
          echo ""
          echo "âœ… All services deployed and verified"
          echo "âœ… API Gateway updated"
          echo "âœ… Version policy updated"
          echo ""
          echo "ğŸ”— API Endpoints:"
          echo "   https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/$VERSION/"
          echo ""
