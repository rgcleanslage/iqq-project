name: Add New API Version

on:
  workflow_dispatch:
    inputs:
      new_version:
        description: 'New version to add (e.g., v3, v4)'
        required: true
        type: string
      status:
        description: 'Initial version status'
        required: true
        type: choice
        options:
          - planned
          - alpha
          - beta
        default: 'planned'
      migration_guide_url:
        description: 'Migration guide URL (optional)'
        required: false
        type: string
        default: 'https://docs.iqq.com/api/migration'
      package_branch:
        description: 'Source branch for package service (default: main)'
        required: false
        type: string
        default: 'main'
      lender_branch:
        description: 'Source branch for lender service (default: main)'
        required: false
        type: string
        default: 'main'
      product_branch:
        description: 'Source branch for product service (default: main)'
        required: false
        type: string
        default: 'main'
      document_branch:
        description: 'Source branch for document service (default: main)'
        required: false
        type: string
        default: 'main'
      infrastructure_branch:
        description: 'Source branch for infrastructure (default: main)'
        required: false
        type: string
        default: 'main'

env:
  AWS_REGION: us-east-1
  GITHUB_ORG: rgcleanslage

concurrency:
  group: add-version-${{ github.event.inputs.new_version }}
  cancel-in-progress: false

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:
  validate-version:
    name: Validate New Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      previous-version: ${{ steps.validate.outputs.previous_version }}
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4
      
      - name: Validate version format
        id: validate
        run: |
          VERSION="${{ github.event.inputs.new_version }}"
          
          # Validate format (v followed by number)
          if ! [[ "$VERSION" =~ ^v[0-9]+$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "   Expected format: v3, v4, v5, etc."
            exit 1
          fi
          
          # Check if version already exists
          if jq -e ".versions[\"$VERSION\"]" config/version-policy.json > /dev/null; then
            echo "âŒ Version $VERSION already exists in configuration"
            exit 1
          fi
          
          # Get current version
          CURRENT_VERSION=$(jq -r '.currentVersion' config/version-policy.json)
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "previous_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          
          echo "âœ… Version $VERSION validated"
          echo "   Previous version: $CURRENT_VERSION"
          echo "   Status: ${{ github.event.inputs.status }}"

  create-migration-guide:
    name: Create Migration Guide
    needs: validate-version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4
      
      - name: Generate migration guide
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          PREV_VERSION="${{ needs.validate-version.outputs.previous-version }}"
          DATE=$(date +"%B %d, %Y")
          
          echo "ğŸ“ Creating migration guide: ${PREV_VERSION} to ${VERSION}..."
          
          mkdir -p docs/api/migrations
          
          cat > docs/api/migrations/MIGRATION_${PREV_VERSION}_TO_${VERSION}.md << 'EOF'
          # Migration Guide: ${PREV_VERSION} to ${VERSION}
          
          **Date**: ${DATE}  
          **Status**: Draft
          
          ## Overview
          
          This guide helps you migrate from API version ${PREV_VERSION} to ${VERSION}.
          
          ## What's New in ${VERSION}
          
          ### New Features
          
          - [ ] TODO: Document new features
          - [ ] TODO: Document new endpoints
          - [ ] TODO: Document new parameters
          
          ### Improvements
          
          - [ ] TODO: Document performance improvements
          - [ ] TODO: Document enhanced functionality
          
          ### Bug Fixes
          
          - [ ] TODO: Document bug fixes
          
          ## Breaking Changes
          
          ### âš ï¸ Important Changes
          
          > **Note**: Update this section with any breaking changes between ${PREV_VERSION} and ${VERSION}
          
          #### 1. [Breaking Change Title]
          
          **What changed:**
          - TODO: Describe the change
          
          **Migration required:**
          - TODO: Describe what clients need to do
          
          **Before (${PREV_VERSION}):**
          \`\`\`json
          {
            "example": "old format"
          }
          \`\`\`
          
          **After (${VERSION}):**
          \`\`\`json
          {
            "example": "new format"
          }
          \`\`\`
          
          ## Deprecated Features
          
          The following features are deprecated in ${VERSION} and will be removed in a future version:
          
          - [ ] TODO: List deprecated features
          
          ## Migration Steps
          
          ### Step 1: Review Breaking Changes
          
          Review all breaking changes listed above and assess impact on your integration.
          
          ### Step 2: Update API Endpoints
          
          Update your API endpoint URLs from ${PREV_VERSION} to ${VERSION}:
          
          **Before:**
          \`\`\`
          https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${PREV_VERSION}/package
          \`\`\`
          
          **After:**
          \`\`\`
          https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/package
          \`\`\`
          
          ### Step 3: Update Request/Response Handling
          
          Update your code to handle any changes in request or response formats.
          
          ### Step 4: Test in Development
          
          Test your integration thoroughly in a development environment:
          
          \`\`\`bash
          # Test package endpoint
          curl -i "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/package?productCode=MBP" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY"
          
          # Test lender endpoint
          curl -i "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/lender?lenderId=LENDER-001" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY"
          
          # Test product endpoint
          curl -i "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/product?productId=PROD-001" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY"
          
          # Test document endpoint
          curl -i "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/document" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY"
          \`\`\`
          
          ### Step 5: Monitor Version Headers
          
          Verify that you're receiving the correct version headers:
          
          \`\`\`bash
          curl -i "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/package?productCode=MBP" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY" | grep -i "x-api-version"
          
          # Should return: x-api-version: ${VERSION}
          \`\`\`
          
          ### Step 6: Deploy to Production
          
          Once testing is complete, deploy your changes to production.
          
          ## Code Examples
          
          ### JavaScript/TypeScript
          
          **Before (${PREV_VERSION}):**
          \`\`\`typescript
          const response = await fetch(
            'https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${PREV_VERSION}/package',
            {
              headers: {
                'Authorization': \`Bearer \${token}\`,
                'x-api-key': apiKey
              }
            }
          );
          \`\`\`
          
          **After (${VERSION}):**
          \`\`\`typescript
          const response = await fetch(
            'https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/package',
            {
              headers: {
                'Authorization': \`Bearer \${token}\`,
                'x-api-key': apiKey
              }
            }
          );
          
          // Check version headers
          const apiVersion = response.headers.get('X-API-Version');
          console.log('API Version:', apiVersion); // Should be: ${VERSION}
          \`\`\`
          
          ### Python
          
          **Before (${PREV_VERSION}):**
          \`\`\`python
          import requests
          
          response = requests.get(
              'https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${PREV_VERSION}/package',
              headers={
                  'Authorization': f'Bearer {token}',
                  'x-api-key': api_key
              }
          )
          \`\`\`
          
          **After (${VERSION}):**
          \`\`\`python
          import requests
          
          response = requests.get(
              'https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/package',
              headers={
                  'Authorization': f'Bearer {token}',
                  'x-api-key': api_key
              }
          )
          
          # Check version headers
          api_version = response.headers.get('X-API-Version')
          print(f'API Version: {api_version}')  # Should be: ${VERSION}
          \`\`\`
          
          ### cURL
          
          **Before (${PREV_VERSION}):**
          \`\`\`bash
          curl "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${PREV_VERSION}/package?productCode=MBP" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY"
          \`\`\`
          
          **After (${VERSION}):**
          \`\`\`bash
          curl "https://r8ukhidr1m.execute-api.us-east-1.amazonaws.com/${VERSION}/package?productCode=MBP" \\
            -H "Authorization: Bearer \$TOKEN" \\
            -H "x-api-key: \$API_KEY"
          \`\`\`
          
          ## API Endpoints
          
          All endpoints are available in ${VERSION}:
          
          | Endpoint | ${PREV_VERSION} URL | ${VERSION} URL |
          |----------|---------------------|----------------|
          | Package | \`/${PREV_VERSION}/package\` | \`/${VERSION}/package\` |
          | Lender | \`/${PREV_VERSION}/lender\` | \`/${VERSION}/lender\` |
          | Product | \`/${PREV_VERSION}/product\` | \`/${VERSION}/product\` |
          | Document | \`/${PREV_VERSION}/document\` | \`/${VERSION}/document\` |
          
          ## Version Headers
          
          ${VERSION} includes the following version headers in all responses:
          
          | Header | Description | Example |
          |--------|-------------|---------|
          | \`X-API-Version\` | Current API version | \`${VERSION}\` |
          | \`X-API-Deprecated\` | Whether version is deprecated | \`false\` |
          | \`X-API-Sunset-Date\` | Sunset date (if deprecated) | \`null\` |
          | \`X-Correlation-ID\` | Request correlation ID | UUID |
          
          ## Rollback Plan
          
          If you encounter issues with ${VERSION}, you can rollback to ${PREV_VERSION}:
          
          1. Update your endpoint URLs back to \`/${PREV_VERSION}/\`
          2. Revert any code changes specific to ${VERSION}
          3. Monitor your application for stability
          4. Report issues to the API team
          
          ## Support
          
          If you need help with migration:
          
          - **Documentation**: https://docs.iqq.com/api
          - **API Reference**: https://docs.iqq.com/api/reference
          - **Support Email**: api-support@iqq.com
          - **GitHub Issues**: https://github.com/rgcleanslage/iqq-project/issues
          
          ## Timeline
          
          - **${VERSION} Release**: TODO: Add release date
          - **${PREV_VERSION} Deprecation**: TODO: Add deprecation date (if applicable)
          - **${PREV_VERSION} Sunset**: TODO: Add sunset date (if applicable)
          
          ## Checklist
          
          Use this checklist to track your migration progress:
          
          - [ ] Review breaking changes
          - [ ] Update endpoint URLs
          - [ ] Update request/response handling
          - [ ] Test in development environment
          - [ ] Verify version headers
          - [ ] Update monitoring/logging
          - [ ] Update documentation
          - [ ] Deploy to staging
          - [ ] Perform integration tests
          - [ ] Deploy to production
          - [ ] Monitor for issues
          
          ## Additional Resources
          
          - [API Versioning Guide](../API_VERSIONING_SETUP.md)
          - [Version Headers Documentation](../API_VERSION_HEADERS.md)
          - [OpenAPI Specification](../openapi-complete.yaml)
          - [Postman Collection](../postman-collection.json)
          
          ---
          
          **Last Updated**: ${DATE}  
          **Status**: Draft - Please update with actual changes
          EOF
          
          # Replace variables in the file
          sed -i "s/\${VERSION}/${VERSION}/g" docs/api/migrations/MIGRATION_${PREV_VERSION}_TO_${VERSION}.md
          sed -i "s/\${PREV_VERSION}/${PREV_VERSION}/g" docs/api/migrations/MIGRATION_${PREV_VERSION}_TO_${VERSION}.md
          sed -i "s/\${DATE}/${DATE}/g" docs/api/migrations/MIGRATION_${PREV_VERSION}_TO_${VERSION}.md
          
          echo "âœ… Migration guide created: docs/api/migrations/MIGRATION_${PREV_VERSION}_TO_${VERSION}.md"
      
      - name: Upload migration guide
        uses: actions/upload-artifact@v4
        with:
          name: migration-guide
          path: docs/api/migrations/

  update-root-config:
    name: Update Root Configuration
    needs: [validate-version, create-migration-guide]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout root repository
        uses: actions/checkout@v4
      
      - name: Download migration guide
        uses: actions/download-artifact@v4
        with:
          name: migration-guide
          path: docs/api/migrations/
      
      - name: Update version policy
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          STATUS="${{ github.event.inputs.status }}"
          MIGRATION_URL="${{ github.event.inputs.migration_guide_url }}"
          PREV_VERSION="${{ needs.validate-version.outputs.previous-version }}"
          
          echo "ğŸ“ Adding $VERSION to version policy..."
          
          # Add new version to policy
          jq --arg version "$VERSION" \
             --arg status "$STATUS" \
             --arg migration "${MIGRATION_URL}/${PREV_VERSION}-to-${VERSION}" \
             '.versions[$version] = {
               "status": $status,
               "sunsetDate": null,
               "migrationGuide": $migration
             }' \
             config/version-policy.json > config/version-policy.json.tmp
          
          mv config/version-policy.json.tmp config/version-policy.json
          
          echo "âœ… Version policy updated"
          cat config/version-policy.json | jq .
      
      - name: Update workflow files
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          
          echo "ğŸ“ Updating workflow files to include $VERSION..."
          
          # Update deploy-version.yml - add version to version options list only
          awk -v version="$VERSION" '
            /version:/ && !found_version_input { found_version_input=1; print; next }
            found_version_input && /options:/ { print; getline; print; print "          - " version; found_version_input=0; next }
            { print }
          ' .github/workflows/deploy-version.yml > .github/workflows/deploy-version.yml.tmp
          mv .github/workflows/deploy-version.yml.tmp .github/workflows/deploy-version.yml
          
          # Update deprecate-version.yml - add version to version options list only
          awk -v version="$VERSION" '
            /version:/ && !found_version_input { found_version_input=1; print; next }
            found_version_input && /options:/ { print; getline; print; print "          - " version; found_version_input=0; next }
            { print }
          ' .github/workflows/deprecate-version.yml > .github/workflows/deprecate-version.yml.tmp
          mv .github/workflows/deprecate-version.yml.tmp .github/workflows/deprecate-version.yml
          
          # Update sunset-version.yml - add version to version options list only
          awk -v version="$VERSION" '
            /version:/ && !found_version_input { found_version_input=1; print; next }
            found_version_input && /options:/ { print; getline; print; print "          - " version; found_version_input=0; next }
            { print }
          ' .github/workflows/sunset-version.yml > .github/workflows/sunset-version.yml.tmp
          mv .github/workflows/sunset-version.yml.tmp .github/workflows/sunset-version.yml
          
          echo "âœ… Workflow files updated"
      
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.PAT_TOKEN }}
          commit-message: "feat: add ${{ needs.validate-version.outputs.version }} to version policy"
          branch: add-version-${{ needs.validate-version.outputs.version }}
          title: "Add API Version ${{ needs.validate-version.outputs.version }}"
          body: |
            ## Add New API Version: ${{ needs.validate-version.outputs.version }}
            
            This PR adds version ${{ needs.validate-version.outputs.version }} to the API versioning configuration.
            
            ### Changes
            - âœ… Updated `config/version-policy.json`
            - âœ… Updated workflow files to include ${{ needs.validate-version.outputs.version }}
            - âœ… Created migration guide: `docs/api/migrations/MIGRATION_${{ needs.validate-version.outputs.previous-version }}_TO_${{ needs.validate-version.outputs.version }}.md`
            
            ### Configuration
            - **Version**: ${{ needs.validate-version.outputs.version }}
            - **Status**: ${{ github.event.inputs.status }}
            - **Migration Guide**: ${{ github.event.inputs.migration_guide_url }}
            
            ### Next Steps
            1. Review and merge this PR
            2. Update Terraform infrastructure (see checklist below)
            3. Deploy services using "Deploy API Version" workflow
            
            ### Infrastructure Checklist
            - [ ] Add ${{ needs.validate-version.outputs.version }} stage to `iqq-infrastructure/modules/api-gateway/main.tf`
            - [ ] Add Lambda permissions for ${{ needs.validate-version.outputs.version }} (4 services)
            - [ ] Add stage URL output
            - [ ] Run `terraform apply`
            
            ### Service Deployment Checklist
            - [ ] Update service version policies (automated by workflow)
            - [ ] Deploy all services via GitHub Actions
            - [ ] Test endpoints
            - [ ] Verify version headers
            
            ### Documentation Checklist
            - [ ] Review and update migration guide
            - [ ] Document breaking changes
            - [ ] Add code examples
            - [ ] Update API reference
            - [ ] Publish migration guide
            
            ---
            
            **Automated by**: Add New API Version workflow
            **Triggered by**: @${{ github.actor }}

  deploy-infrastructure:
    name: Deploy Infrastructure with AWS CLI
    needs: [validate-version, update-root-config]
    runs-on: ubuntu-latest
    outputs:
      stage-url: ${{ steps.create-stage.outputs.stage_url }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get API Gateway ID
        id: get-api
        run: |
          # Get API Gateway ID from existing deployment
          API_ID=$(aws apigateway get-rest-apis \
            --query 'items[?name==`iqq-api-dev`].id' \
            --output text)
          
          if [ -z "$API_ID" ]; then
            echo "âŒ API Gateway not found"
            exit 1
          fi
          
          echo "api_id=$API_ID" >> $GITHUB_OUTPUT
          echo "âœ… API Gateway ID: $API_ID"
      
      - name: Get deployment ID
        id: get-deployment
        run: |
          API_ID="${{ steps.get-api.outputs.api_id }}"
          
          # Get latest deployment
          DEPLOYMENT_ID=$(aws apigateway get-deployments \
            --rest-api-id "$API_ID" \
            --query 'items[0].id' \
            --output text)
          
          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "âŒ No deployments found"
            exit 1
          fi
          
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "âœ… Deployment ID: $DEPLOYMENT_ID"
      
      - name: Create API Gateway stage
        id: create-stage
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"
          DEPLOYMENT_ID="${{ steps.get-deployment.outputs.deployment_id }}"
          
          echo "ğŸš€ Creating API Gateway stage: $VERSION"
          
          # Check if stage already exists
          if aws apigateway get-stage \
            --rest-api-id "$API_ID" \
            --stage-name "$VERSION" 2>/dev/null; then
            echo "â„¹ï¸  Stage $VERSION already exists"
            STAGE_URL="https://${API_ID}.execute-api.${AWS_REGION}.amazonaws.com/${VERSION}"
          else
            # Create stage
            aws apigateway create-stage \
              --rest-api-id "$API_ID" \
              --stage-name "$VERSION" \
              --deployment-id "$DEPLOYMENT_ID" \
              --variables lambdaAlias="$VERSION" \
              --tags Name="iqq-api-${VERSION}-dev",Stage="$VERSION",Environment="dev"
            
            STAGE_URL="https://${API_ID}.execute-api.${AWS_REGION}.amazonaws.com/${VERSION}"
            echo "âœ… Stage $VERSION created"
          fi
          
          echo "stage_url=$STAGE_URL" >> $GITHUB_OUTPUT
          echo "ğŸ”— Stage URL: $STAGE_URL"
      
      - name: Add Lambda permissions
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"
          ENV="dev"
          
          echo "ğŸ” Adding Lambda permissions for $VERSION..."
          
          for SERVICE in package lender product document; do
            FUNCTION_NAME="iqq-${SERVICE}-service-${ENV}"
            STATEMENT_ID="AllowAPIGatewayInvoke${VERSION^^}"
            
            echo "  Adding permission for $FUNCTION_NAME..."
            
            # Remove existing permission if it exists
            aws lambda remove-permission \
              --function-name "$FUNCTION_NAME" \
              --statement-id "$STATEMENT_ID" \
              --qualifier "$VERSION" 2>/dev/null || true
            
            # Add permission
            aws lambda add-permission \
              --function-name "$FUNCTION_NAME" \
              --statement-id "$STATEMENT_ID" \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${AWS_REGION}:*:${API_ID}/${VERSION}/GET/${SERVICE}" \
              --qualifier "$VERSION" 2>/dev/null || {
                echo "  âš ï¸  Permission may already exist or alias not created yet"
              }
            
            echo "  âœ… Permission added for $FUNCTION_NAME"
          done
          
          echo "âœ… All Lambda permissions configured"
      
      - name: Verify stage
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          API_ID="${{ steps.get-api.outputs.api_id }}"
          
          echo "ğŸ” Verifying stage configuration..."
          
          STAGE_INFO=$(aws apigateway get-stage \
            --rest-api-id "$API_ID" \
            --stage-name "$VERSION")
          
          echo "$STAGE_INFO" | jq '{
            stageName: .stageName,
            deploymentId: .deploymentId,
            variables: .variables,
            createdDate: .createdDate
          }'
          
          echo "âœ… Stage verified successfully"

  update-infrastructure:
    name: Generate Terraform Code for IaC
    needs: [validate-version, deploy-infrastructure]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.GITHUB_ORG }}/iqq-infrastructure
          token: ${{ secrets.PAT_TOKEN }}
      
      - name: Generate Terraform changes
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          
          echo "ğŸ“ Generating Terraform configuration for $VERSION..."
          
          # Create a file with the new stage configuration
          cat > /tmp/new-stage.tf << EOF
          # $VERSION stage
          resource "aws_api_gateway_stage" "$VERSION" {
            deployment_id = aws_api_gateway_deployment.main.id
            rest_api_id   = aws_api_gateway_rest_api.main.id
            stage_name    = "$VERSION"
            
            variables = {
              lambdaAlias = "$VERSION"
            }
            
            xray_tracing_enabled = true
            
            access_log_settings {
              destination_arn = aws_cloudwatch_log_group.api_gateway.arn
              format = jsonencode({
                requestId      = "\$context.requestId"
                ip             = "\$context.identity.sourceIp"
                requestTime    = "\$context.requestTime"
                httpMethod     = "\$context.httpMethod"
                resourcePath   = "\$context.resourcePath"
                status         = "\$context.status"
                protocol       = "\$context.protocol"
                responseLength = "\$context.responseLength"
                stage          = "\$context.stage"
                lambdaAlias    = "\$stageVariables.lambdaAlias"
              })
            }
            
            tags = merge(
              var.common_tags,
              {
                Name        = "\${var.project_name}-api-$VERSION-\${var.environment}"
                Stage       = "$VERSION"
                Environment = var.environment
              }
            )
          }
          
          # Lambda permissions for $VERSION
          resource "aws_lambda_permission" "package_$VERSION" {
            statement_id  = "AllowAPIGatewayInvoke${VERSION^^}"
            function_name = var.package_function_name
            principal     = "apigateway.amazonaws.com"
            source_arn    = "\${aws_api_gateway_rest_api.main.execution_arn}/$VERSION/GET/package"
            qualifier     = "$VERSION"
          }
          
          resource "aws_lambda_permission" "lender_$VERSION" {
            statement_id  = "AllowAPIGatewayInvoke${VERSION^^}"
            function_name = var.lender_function_name
            principal     = "apigateway.amazonaws.com"
            source_arn    = "\${aws_api_gateway_rest_api.main.execution_arn}/$VERSION/GET/lender"
            qualifier     = "$VERSION"
          }
          
          resource "aws_lambda_permission" "product_$VERSION" {
            statement_id  = "AllowAPIGatewayInvoke${VERSION^^}"
            function_name = var.product_function_name
            principal     = "apigateway.amazonaws.com"
            source_arn    = "\${aws_api_gateway_rest_api.main.execution_arn}/$VERSION/GET/product"
            qualifier     = "$VERSION"
          }
          
          resource "aws_lambda_permission" "document_$VERSION" {
            statement_id  = "AllowAPIGatewayInvoke${VERSION^^}"
            function_name = var.document_function_name
            principal     = "apigateway.amazonaws.com"
            source_arn    = "\${aws_api_gateway_rest_api.main.execution_arn}/$VERSION/GET/document"
            qualifier     = "$VERSION"
          }
          EOF
          
          echo "âœ… Terraform configuration generated"
          echo ""
          echo "Generated configuration:"
          cat /tmp/new-stage.tf
      
      - name: Create infrastructure instructions
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          STAGE_URL="${{ needs.deploy-infrastructure.outputs.stage-url }}"
          
          cat > INFRASTRUCTURE_UPDATE.md << EOF
          # Infrastructure Update for $VERSION
          
          ## âœ… Infrastructure Already Deployed
          
          The infrastructure for $VERSION has been automatically deployed using AWS CLI:
          
          - âœ… API Gateway stage created: $VERSION
          - âœ… Lambda permissions added (4 services)
          - âœ… Stage URL: $STAGE_URL
          
          ## Terraform Code (For IaC Compliance)
          
          To bring this infrastructure under Terraform management, follow these steps:
          
          ### Option 1: Import Existing Resources (Recommended)
          
          \`\`\`bash
          # Import the stage
          terraform import module.api_gateway.aws_api_gateway_stage.${VERSION} \${API_ID}/${VERSION}
          
          # Import Lambda permissions
          terraform import module.api_gateway.aws_lambda_permission.package_${VERSION} \${FUNCTION_NAME}/AllowAPIGatewayInvoke${VERSION^^}
          terraform import module.api_gateway.aws_lambda_permission.lender_${VERSION} \${FUNCTION_NAME}/AllowAPIGatewayInvoke${VERSION^^}
          terraform import module.api_gateway.aws_lambda_permission.product_${VERSION} \${FUNCTION_NAME}/AllowAPIGatewayInvoke${VERSION^^}
          terraform import module.api_gateway.aws_lambda_permission.document_${VERSION} \${FUNCTION_NAME}/AllowAPIGatewayInvoke${VERSION^^}
          \`\`\`
          
          ### Option 2: Add Terraform Code
          
          Edit \`modules/api-gateway/main.tf\` and add:
          
          \`\`\`hcl
          $(cat /tmp/new-stage.tf)
          \`\`\`
          
          Edit \`modules/api-gateway/outputs.tf\` and add:
          
          \`\`\`hcl
          output "${VERSION}_stage_url" {
            description = "URL for $VERSION stage"
            value       = "\${aws_api_gateway_stage.${VERSION}.invoke_url}"
          }
          \`\`\`
          
          Then run:
          \`\`\`bash
          terraform plan  # Should show resources already exist
          terraform import ...  # Import existing resources
          \`\`\`
          
          ### Option 3: Leave as-is
          
          The infrastructure is fully functional. You can leave it managed via AWS CLI
          and add Terraform code later if needed.
          
          ## Next Steps
          
          1. âœ… Infrastructure is ready - no action required
          2. Deploy services using "Deploy API Version" workflow
          3. Test endpoints at: $STAGE_URL
          
          ---
          
          **Note**: Infrastructure was automatically deployed via AWS CLI for speed.
          Terraform code is provided for IaC compliance if desired.
          EOF
          
          echo "âœ… Infrastructure instructions created"
      
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.PAT_TOKEN }}
          commit-message: "feat: add ${{ needs.validate-version.outputs.version }} infrastructure configuration"
          branch: add-version-${{ needs.validate-version.outputs.version }}
          title: "Infrastructure: Add API Version ${{ needs.validate-version.outputs.version }}"
          body: |
            ## Infrastructure Update for ${{ needs.validate-version.outputs.version }}
            
            ### âœ… Infrastructure Automatically Deployed
            
            The infrastructure for ${{ needs.validate-version.outputs.version }} has been automatically created using AWS CLI:
            
            - âœ… API Gateway stage: ${{ needs.validate-version.outputs.version }}
            - âœ… Lambda permissions: 4 services configured
            - âœ… Stage URL: ${{ needs.deploy-infrastructure.outputs.stage-url }}
            
            ### Terraform Code Provided
            
            This PR includes Terraform code for IaC compliance. You can:
            
            1. **Import existing resources** into Terraform state (recommended)
            2. **Add Terraform code** and import resources
            3. **Leave as-is** - infrastructure is fully functional
            
            See `INFRASTRUCTURE_UPDATE.md` for detailed instructions.
            
            ### Next Steps
            
            1. âœ… Infrastructure is ready - no manual steps required
            2. Deploy services via "Deploy API Version" workflow
            3. Test endpoints at: ${{ needs.deploy-infrastructure.outputs.stage-url }}
            
            ### Optional: Terraform Import
            
            To bring resources under Terraform management:
            
            \`\`\`bash
            # See INFRASTRUCTURE_UPDATE.md for import commands
            terraform import module.api_gateway.aws_api_gateway_stage.${{ needs.validate-version.outputs.version }} ...
            \`\`\`
            
            ---
            
            **Automated by**: Add New API Version workflow  
            **Infrastructure**: Deployed via AWS CLI  
            **Terraform**: Code provided for IaC compliance
            2. Add Lambda permissions (4 services)
            3. Add output to `modules/api-gateway/outputs.tf`
            4. Run `terraform apply`
            
            ### After Terraform Apply
            
            Run the "Deploy API Version" workflow:
            - Version: ${{ needs.validate-version.outputs.version }}
            - Services: all
            - Environment: dev
            
            ---
            
            **Automated by**: Add New API Version workflow
            **Triggered by**: @${{ github.actor }}

  update-service-configs:
    name: Update Service Configurations
    needs: validate-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [package, lender, product, document]
    steps:
      - name: Checkout service repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.GITHUB_ORG }}/iqq-${{ matrix.service }}-service
          token: ${{ secrets.PAT_TOKEN }}
      
      - name: Update version policy
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          STATUS="${{ github.event.inputs.status }}"
          MIGRATION_URL="${{ github.event.inputs.migration_guide_url }}"
          PREV_VERSION="${{ needs.validate-version.outputs.previous-version }}"
          
          echo "ğŸ“ Adding $VERSION to iqq-${{ matrix.service }}-service version policy..."
          
          jq --arg version "$VERSION" \
             --arg status "$STATUS" \
             --arg migration "${MIGRATION_URL}/${PREV_VERSION}-to-${VERSION}" \
             '.versions[$version] = {
               "status": $status,
               "sunsetDate": null,
               "migrationGuide": $migration
             }' \
             src/config/version-policy.json > src/config/version-policy.json.tmp
          
          mv src/config/version-policy.json.tmp src/config/version-policy.json
          
          echo "âœ… Version policy updated for ${{ matrix.service }} service"
      
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.PAT_TOKEN }}
          commit-message: "feat: add ${{ needs.validate-version.outputs.version }} to version policy"
          branch: add-version-${{ needs.validate-version.outputs.version }}
          title: "Add Version ${{ needs.validate-version.outputs.version }} Configuration"
          body: |
            ## Add Version ${{ needs.validate-version.outputs.version }}
            
            Updates version policy configuration for the ${{ matrix.service }} service.
            
            ### Changes
            - âœ… Updated `src/config/version-policy.json`
            
            ### Configuration
            - **Version**: ${{ needs.validate-version.outputs.version }}
            - **Status**: ${{ github.event.inputs.status }}
            
            ### Next Steps
            1. Review and merge this PR
            2. Wait for infrastructure deployment
            3. Deploy via "Deploy API Version" workflow
            
            ---
            
            **Automated by**: Add New API Version workflow
            **Part of**: Root PR #[link to root PR]

  create-release-branches:
    name: Create Release Branches
    needs: validate-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        repo: [iqq-package-service, iqq-lender-service, iqq-product-service, iqq-document-service, iqq-infrastructure]
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.GITHUB_ORG }}/${{ matrix.repo }}
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0
      
      - name: Create release branch
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          BRANCH_NAME="release/$VERSION"
          REPO="${{ matrix.repo }}"
          
          # Determine source branch based on repository
          case "$REPO" in
            iqq-package-service)
              SOURCE_BRANCH="${{ github.event.inputs.package_branch }}"
              ;;
            iqq-lender-service)
              SOURCE_BRANCH="${{ github.event.inputs.lender_branch }}"
              ;;
            iqq-product-service)
              SOURCE_BRANCH="${{ github.event.inputs.product_branch }}"
              ;;
            iqq-document-service)
              SOURCE_BRANCH="${{ github.event.inputs.document_branch }}"
              ;;
            iqq-infrastructure)
              SOURCE_BRANCH="${{ github.event.inputs.infrastructure_branch }}"
              ;;
            *)
              SOURCE_BRANCH="main"
              ;;
          esac
          
          echo "ğŸŒ¿ Creating release branch: $BRANCH_NAME in $REPO from $SOURCE_BRANCH"
          
          # Check if branch already exists on remote
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "â„¹ï¸  Branch $BRANCH_NAME already exists on remote"
            exit 0
          fi
          
          # Fetch and checkout source branch
          git fetch origin "$SOURCE_BRANCH"
          git checkout "$SOURCE_BRANCH" 2>/dev/null || git checkout -b "$SOURCE_BRANCH" "origin/$SOURCE_BRANCH"
          git pull origin "$SOURCE_BRANCH"
          
          # Create and push release branch from source branch
          git checkout -b "$BRANCH_NAME"
          git push -u origin "$BRANCH_NAME"
          
          echo "âœ… Created and pushed branch $BRANCH_NAME in $REPO from $SOURCE_BRANCH"

  notify-completion:
    name: Notify Completion
    needs: [validate-version, update-root-config, update-infrastructure, update-service-configs, create-release-branches, deploy-infrastructure]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          VERSION="${{ needs.validate-version.outputs.version }}"
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ Add New API Version Complete"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Version: $VERSION"
          echo "Status: ${{ github.event.inputs.status }}"
          echo ""
          echo "âœ… Pull requests created in:"
          echo "   - iqq-project (root repository)"
          echo "   - iqq-infrastructure"
          echo "   - iqq-package-service"
          echo "   - iqq-lender-service"
          echo "   - iqq-product-service"
          echo "   - iqq-document-service"
          echo ""
          echo "âœ… Release branches created:"
          echo "   - iqq-package-service/release/$VERSION"
          echo "   - iqq-lender-service/release/$VERSION"
          echo "   - iqq-product-service/release/$VERSION"
          echo "   - iqq-document-service/release/$VERSION"
          echo "   - iqq-infrastructure/release/$VERSION"
          echo ""
          echo "âœ… Infrastructure deployed:"
          echo "   - API Gateway stage: $VERSION"
          echo "   - Lambda permissions: 4 services"
          echo "   - Stage URL: ${{ needs.deploy-infrastructure.outputs.stage-url }}"
          echo ""
          echo "ğŸ“‹ Next Steps:"
          echo "   1. Review and merge all PRs"
          echo "   2. Deploy services using 'Deploy API Version' workflow"
          echo "   3. Test endpoints"
          echo "   4. (Optional) Import infrastructure into Terraform"
          echo "   - iqq-product-service"
          echo "   - iqq-document-service"
          echo ""
          echo "ğŸ“‹ Next Steps:"
          echo "   1. Review and merge all PRs"
          echo "   2. Follow infrastructure update instructions"
          echo "   3. Run 'Deploy API Version' workflow"
          echo "   4. Test new version endpoints"
          echo ""
          echo "ğŸ”— Workflow Run:"
          echo "   https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
